#!/usr/bin/env bash
# clip - Utility for clipboard operations in Ubuntu/Linux desktop systems
#
# This script allows copying file contents to clipboard and
# pasting clipboard contents to files or stdout.
#
set -euo pipefail

# Script metadata
VERSION='1.0.0'
PRG0=$(readlink -en -- "$0")       # Full path to script
PRG=${PRG0##*/}                    # Script basename
readonly -- VERSION PRG0 PRG

# Global variable declarations
declare -i VERBOSE=1 COMPRESS=0 QUALITY=90 USE_FILE_HEADER=0
declare -- COMPRESS_MODE='optimize'  # 'optimize' or 'resize'
declare -- FILE_HEADER='```text {}\n'
declare -- FILE_FOOTER='\n```\n\n'

# Executable paths (will be set later)
declare -- CLIP=''
declare -- CONVERT=''
declare -- OPTIPNG=''
declare -- PNGQUANT=''

# Color support for terminal output
#shellcheck disable=SC2015
[[ -t 2 ]] && declare -- RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m' || declare -- RED='' GREEN='' YELLOW='' CYAN='' NC=''
readonly -- RED GREEN YELLOW CYAN NC

# Utility functions
decp() { declare -p "$@" | sed 's/^declare -[a-zA-Z-]* //'; }

# Core message function using FUNCNAME for context
_msg() {
  local -- status="${FUNCNAME[1]}" prefix="$PRG" msg
  case "$status" in
    success) prefix+=": ${GREEN}✓${NC}" ;;
    warn)    prefix+=": ${YELLOW}⚡${NC}" ;;
    info)    prefix+=": ${CYAN}◉${NC}" ;;
    error)   prefix+=": ${RED}✗${NC}" ;;
    *) ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}
# Messaging functions
success() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
error() { >&2 _msg "$@"; }
die() { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }

yn() {
  read -r -n1 -p "$PRG: $YELLOW$1$NC y/n "
  echo
  [[ ${REPLY,,} == y ]]
}

# Display help information
usage() {
  cat <<EOT
$PRG $VERSION - Terminal clipboard utility

Copies contents of files to clipboard;
Pastes contents of clipboard to file (supports both text and images).

Usage:
    # Copy mode
    $PRG filename [filename ...]
  or:
    # Paste mode
    $PRG -p [filename]

Requires: xclip (and optionally PNG optimizers for compression)

Options:
  -p, --paste     Paste clipboard contents to file or stdout.
                  Default is copy.

  -c, --compress  Optimize PNG image when pasting (requires optipng/pngquant)
                  [$(decp COMPRESS)]
  -r, --resize    Use resize-based compression instead of optimization
                  [$(decp COMPRESS) $(decp COMPRESS_MODE)]
  -Q, --quality N Set compression quality/level (1-100, $(decp QUALITY))

  -f, --use-file-header
                  Add header/footer to copied files
                  [$(decp USE_FILE_HEADER)]
  -H, --file-header HEADER
                  Custom file header (use {} for filename)
                  [$(decp FILE_HEADER)]
  -F, --file-footer FOOTER
                  Custom file footer
                  [$(decp FILE_FOOTER)]

  -v, --verbose   Enable verbose output (default)
  -q, --quiet     Disable verbose output

  -V, --version   Display version [$(decp VERSION)]
  -h, --help      Display this help message

Examples:
  $PRG myfile.txt
  $PRG /tmp/myfile.md $HOME/myotherfile.md

  $PRG -p
  $PRG -p newfile.txt
  $PRG -p screenshot.png         # Works with image data
  $PRG -p -c screenshot.png      # Optimize the PNG image (smaller file size)
  $PRG -p -r -Q 75 image.png     # Compress with resize-based method at 75% quality
  $PRG README.md CLAUDE.md -f -H '<file name="{}"><![CDATA[\n' -F ']]></file>\n\n'

EOT
  exit "${1:-0}"
}

# Main function that handles argument parsing and operation mode selection
#
# Arguments:
#   $@ - Command line arguments
main() {
  local -a Files=()
  local -i pastemode=0

  # Process command-line arguments
  while (($#)); do case "$1" in
    -f|--use-file-header)
                   USE_FILE_HEADER=1 ;;
    -H|--file-header)
                   shift; FILE_HEADER="${1:-}" ;;
    -F|--file-footer)
                   shift; FILE_FOOTER="${1:-}" ;;
    -p|--paste)    pastemode=1 ;;
    -c|--compress) COMPRESS=1 ;;
    -r|--resize)   COMPRESS=1; COMPRESS_MODE=resize ;;
    -Q|--quality)  shift; QUALITY="${1:-}" ;;
    -v|--verbose)  VERBOSE=1 ;;
    -q|--quiet)    VERBOSE=0 ;;
    -V|--version)  echo "$PRG ${VERSION}"; exit 0 ;;
    -h|--help)     usage 0 ;;
    -[fHFpcrQvqVh]*) # Handle combined short options
                   #shellcheck disable=SC2046  # Intentional word splitting
                   set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}" ;;
    --)            shift; Files+=( "$@" ); break ;;
    -*)            die 22 "Invalid option '$1'" ;;
    *)             Files+=( "$1" ) ;;
  esac; shift; done

  # Check for GUI environment
  if [[ -z ${DISPLAY:-} ]] && [[ -z ${WAYLAND_DISPLAY:-} ]]; then
    die 1 'No GUI detected. This script requires a graphical desktop environment.' \
          'DISPLAY and WAYLAND_DISPLAY variables are not set.'
  fi

  # Check if xclip is installed, install if missing
  CLIP=$(command -v xclip || true)
  if [[ -z $CLIP ]]; then
    yn 'Install xclip?' || die 1 'xclip is required but not installed'
    info 'Installing xclip'
    sudo apt install -y xclip &>/dev/null || die 1 'Failed to install xclip'
    CLIP=$(command -v xclip)
  fi

  if ((COMPRESS)); then
    # Check for PNG optimization tools
    PNGQUANT=$(command -v pngquant || true)
    OPTIPNG=$(command -v optipng || true)
    CONVERT=$(command -v convert || true)

    if [[ $COMPRESS_MODE == optimize ]] && [[ -z $PNGQUANT ]] && [[ -z $OPTIPNG ]]; then
      yn 'Install pngquant and optipng?' || die 1 'Operation aborted'
      info 'Installing PNG optimization tools'
      sudo apt install -y pngquant optipng &>/dev/null
      PNGQUANT=$(command -v pngquant || true)
      OPTIPNG=$(command -v optipng || true)
    fi

    if [[ -z $CONVERT ]] && { [[ $COMPRESS_MODE == resize ]] || { [[ $COMPRESS_MODE == optimize ]] && [[ -z $PNGQUANT ]] && [[ -z $OPTIPNG ]]; }; }; then
      yn 'Install imagemagick?' || die 1 'Operation aborted'
      info 'Installing ImageMagick for image processing'
      sudo apt install -y imagemagick &>/dev/null
      CONVERT=$(command -v convert)
    fi
  fi

  # Run in appropriate mode
  if ((pastemode)); then
    paste_contents_of_clipboard_to_file "${Files[@]}"
  else
    copy_contents_of_files_to_clipboard "${Files[@]}"
  fi
}

# Copy content of one or more files to the clipboard
#
# Arguments:
#   $@ - List of files to copy
#
# Returns:
#   0 on success, 1 if no valid files were found
copy_contents_of_files_to_clipboard() {
  local -a Files=()
  local -- file

  # Process each file argument
  for file in "$@"; do
    if [[ ! -f "$file" ]]; then
      error "File '$file' not found"
      continue
    fi
    Files+=("$file")
  done
  # Check if we have any valid files
  ((${#Files[@]})) || die 1 'No files to copy to clipboard'
  # Copy concatenated file contents to clipboard
  { local -i ccc=0
    for file in "${Files[@]}"; do
      ((ccc+=1))
      _fileheader "$ccc" "$file"
      cat -s -- "$file"
      _filefooter "$ccc" "$file"
    done
  } | nohup "$CLIP" -selection clipboard -i >/dev/null 2>&1 &
  # Show success message if verbose mode enabled
  local -- plural=''
  ((${#Files[@]} == 1)) || plural='s'
  success "File${plural} '${Files[*]}' copied to clipboard"
}

# Internal helper for file header
_fileheader() {
  ((USE_FILE_HEADER)) || return 0
  echo -en "${FILE_HEADER//\{\}/"$2"}"
}

# Internal helper for file footer
_filefooter() {
  ((USE_FILE_HEADER)) || return 0
  echo -en "${FILE_FOOTER//\{\}/"$2"}"
}

# Paste clipboard contents to stdout or a file
#
# Arguments:
#   $1 - (Optional) Output file path. If not provided, outputs to stdout
#
# Returns:
#   0 on success, exits with code 1 if destination directory doesn't exist
paste_contents_of_clipboard_to_file() {
  # Paste to stdout?
  if (($# == 0)); then
    "$CLIP" -selection clipboard -o
    return $?
  fi

  # Paste to file
  (($# > 1)) && warn "Can only paste to one file: '${*:2}' ignored"
  local -- output_file="$1" dir_name temp_file temp_file2 file_size1 file_size2
  dir_name=$(dirname "$output_file")

  if [[ ! -d "$dir_name" ]]; then
    info "Directory '$dir_name' does not exist. Creating ..."
    mkdir -p "$dir_name" || die 1 "Could not create '$dir_name'"
  fi
  if ((VERBOSE)) && [[ -f "$output_file" ]] && [[ -t 1 ]]; then
    warn "'$output_file' already exists."
    yn 'Overwrite?' || die 1 'Operation aborted'
  fi
  touch "$output_file" || die 1 "Could not create '$output_file'"
  
  # Check if clipboard contains image data
  if "$CLIP" -selection clipboard -t TARGETS -o | grep -q "image/png"; then
    info 'Detected image data in clipboard'
    
    if ((COMPRESS)); then
      # Create temporary files
      temp_file=$(mktemp)
      temp_file2=$(mktemp)
      
      # First save the raw PNG
      "$CLIP" -selection clipboard -t image/png -o > "$temp_file"
      file_size1=$(stat -c%s "$temp_file")
      info "Original image size: $file_size1 bytes"
      
      if [[ $COMPRESS_MODE == "optimize" ]]; then
        info 'Using PNG optimization'
        
        # Try pngquant first for best compression
        if [[ -n "$PNGQUANT" ]]; then
          info "Optimizing with pngquant (quality: $QUALITY)"
          "$PNGQUANT" --quality=0-"$QUALITY" --skip-if-larger --force --output "$temp_file2" "$temp_file"
        elif [[ -n "$OPTIPNG" ]]; then
          # Calculate optipng level (0-7) from quality (0-100)
          local optilevel=$(( 7 - QUALITY / 15 ))
          [[ $optilevel -lt 0 ]] && optilevel=0
          [[ $optilevel -gt 7 ]] && optilevel=7
          
          info "Optimizing with optipng (level: $optilevel)"
          "$OPTIPNG" -o"$optilevel" -quiet -out "$temp_file2" "$temp_file"
        elif [[ -n "$CONVERT" ]]; then
          # Fallback to ImageMagick with options that actually reduce size
          info 'Optimizing with ImageMagick'
          "$CONVERT" "$temp_file" -strip -define png:compression-filter=5 -define png:compression-level=9 -define png:compression-strategy=1 "$temp_file2"
        else
          warn 'No PNG optimization tools available'
          cp "$temp_file" "$temp_file2"
        fi
      else
        # Resize-based compression
        if [[ -n "$CONVERT" ]]; then
          # Convert quality (1-100) to resize percentage (1-100)
          info "Resizing image with quality: $QUALITY%"
          "$CONVERT" "$temp_file" -resize "$QUALITY%" "$temp_file2"
        else
          warn 'ImageMagick not available for resize compression'
          cp "$temp_file" "$temp_file2"
        fi
      fi
      
      # Check if the compressed file is actually smaller
      file_size2=$(stat -c%s "$temp_file2")
      info "Compressed image size: $file_size2 bytes"
      
      if [[ $file_size2 -lt $file_size1 ]]; then
        success "Compression successful, saved $(( file_size1 - file_size2 )) bytes"
        cp "$temp_file2" "$output_file"
      else
        info 'Compression did not reduce file size, using original'
        cp "$temp_file" "$output_file"
      fi
      
      # Remove temporary files
      rm -f "$temp_file" "$temp_file2"
    else
      # Write image directly to file without compression
      "$CLIP" -selection clipboard -t image/png -o > "$output_file"
    fi
  else
    # Write text to file
    "$CLIP" -selection clipboard -o > "$output_file"
  fi
  
  # Show success message if verbose mode enabled
  success "Clipboard contents pasted to '$output_file'"
}

: <<-'EOT'
```xml
<?xml version="1.0" encoding="UTF-8"?>
<Files>
  <file>
    <name>report.pdf</name>
    <type>application/pdf</type>
    <size>1245678</size>
    <modified>2023-06-15T14:32:17</modified>
    <content><![CDATA[some content]]>
  </file>
  <file>
    <name>presentation.odp</name>
    <type>application/vnd.oasis.opendocument.presentation</type>
    <size>3456789</size>
    <modified>2023-06-10T09:15:43</modified>
    <content><![CDATA[some more content]]>
  </file>
...
</Files>
```
EOT

main "$@"
#fin
