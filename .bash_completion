#!/bin/bash
# Bash completion for clip command

_clip() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # All options available
    opts="-p --paste -c --compress -r --resize -Q --quality -f --use-file-header -H --file-header -F --file-footer -v --verbose -q --quiet -V --version -h --help"

    case $prev in
        -Q|--quality)
            # Completion for quality values (1-100)
            COMPREPLY=( $(compgen -W "10 25 50 75 85 90 95 100" -- "$cur") )
            return 0
            ;;
        -H|--file-header|-F|--file-footer)
            # No completion for header/footer strings
            return 0
            ;;
        *)
            ;;
    esac

    # Check if we're in paste mode by looking for -p or --paste in the command line
    local paste_mode=0
    local i
    for ((i=1; i<COMP_CWORD; i++)); do
        case "${COMP_WORDS[i]}" in
            -p|--paste)
                paste_mode=1
                break
                ;;
        esac
    done

    # If current word starts with dash, complete options
    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
        return 0
    fi

    # In paste mode, complete with file paths for output
    if [[ $paste_mode -eq 1 ]]; then
        COMPREPLY=( $(compgen -f -- "$cur") )
        return 0
    fi

    # In copy mode (default), complete with existing files only
    COMPREPLY=( $(compgen -f -- "$cur") )

    # Filter to only include regular files (not directories)
    local filtered=()
    local item
    for item in "${COMPREPLY[@]}"; do
        if [[ -f "$item" ]] || [[ "$item" == */ ]] || [[ ! -e "$item" ]]; then
            filtered+=("$item")
        fi
    done
    COMPREPLY=("${filtered[@]}")

    return 0
}

# Register the completion function
complete -F _clip clip

#fin